# Тестовое задание
Для хранения иерархической структуры, такой как дерево, в базе данных существует несколько способов представления отношений между элементами. Вот несколько распространенных подходов:
- Модель списка смежности
- Модель вложенных множеств
- Модель материализованного пути
- Модель Closure Table
### Для хранения связей между элементами древовидной структуры в базе данных можно использовать технику, называемую "моделью вложенных множеств". В этой модели каждому узлу дерева присваивается два номера - "левый" и "правый". Левый номер представляет собой позицию узла в обходе дерева, а правый номер - конец поддерева, корень которого находится в этом узле. Левый и правый номера присваиваются таким образом, что левый номер любого узла всегда меньше левого номера его потомков, а правый номер любого узла всегда больше правого номера его потомков.
Чтобы реализовать метод получения списка всех потомков в древовидной форме с использованием модели вложенного множества, мы можем использовать рекурсивный SQL-запрос. Вот пример реализации на языке SQL:
```
WITH RECURSIVE descendants AS (
  SELECT id, name, lft, rgt
  FROM tree
  WHERE name = 'root' -- start with the root node

  UNION ALL

  SELECT tree.id, tree.name, tree.lft, tree.rgt
  FROM tree
  JOIN descendants ON tree.lft > descendants.lft AND tree.rgt < descendants.rgt
)
SELECT id, name, lft, rgt
FROM descendants;
```
В этом примере мы предполагаем, что дерево таблицы имеет столбцы id (уникальный идентификатор), name (имя узла), lft (левый номер) и rgt (правый номер). Мы начинаем с корневого узла (который, как мы предполагаем, имеет имя "root") и рекурсивно соединяемся с узлами, которые являются потомками текущего набора узлов. В результате мы получаем список всех узлов дерева с их левыми и правыми номерами.

Чтобы получить всех потомков узла в виде плоского списка, мы можем использовать модифицированную версию запроса модели вложенного множества, которая возвращает только идентификаторы потомков. Вот пример реализации на PHP с использованием PDO:

```
function getDescendantIds($pdo, $nodeId) {
  $query = "
    WITH RECURSIVE descendants AS (
      SELECT id, lft, rgt
      FROM tree
      WHERE id = :nodeId

      UNION ALL

      SELECT tree.id, tree.lft, tree.rgt
      FROM tree
      JOIN descendants ON tree.lft > descendants.lft AND tree.rgt < descendants.rgt
    )
    SELECT id
    FROM descendants
    WHERE id != :nodeId;
  ";

  $stmt = $pdo->prepare($query);
  $stmt->bindValue(':nodeId', $nodeId, PDO::PARAM_INT);
  $stmt->execute();

  $descendantIds = [];
  while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
    $descendantIds[] = $row['id'];
  }

  return $descendantIds;
}
```
В данной реализации мы предполагаем, что таблица дерева имеет столбцы id, lft и rgt, и что аргумент $nodeId является ID узла, потомков которого мы хотим получить. Запрос возвращает все идентификаторы потомков, кроме идентификатора начального узла.

Для повышения производительности мы можем добавить индекс на столбцы lft и rgt, чтобы ускорить рекурсивный обход дерева. Мы также можем кэшировать результаты запроса для часто посещаемых узлов, чтобы избежать многократного повторения одного и того же запроса. 
